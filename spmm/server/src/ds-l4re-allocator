// vim:set ft=cpp:
// TODO: think about race condition here

#pragma once

#include <l4/re/env>
#include <l4/re/error_helper>
#include <l4/re/util/cap_alloc>

#include <cstdio>
#include <list>
#include <vector>

#include "allocator"

using L4Re::chkcap;
using L4Re::chksys;

namespace Spmm
{

struct extint_t
{
  l4_addr_t ds_start_ext;
  l4_addr_t ds_start_int;
  L4::Cap<L4Re::Dataspace> ds_cap_int;
};

typedef std::list<extint_t> extint_map_t;

class BitmapAllocator
{
private:
  friend class DsL4ReAllocator;
  L4::Cap<L4Re::Dataspace> _buffer_cap;
  l4_addr_t _buffer_addr;
  // TODO: add typedef here
  std::vector<bool> _free_pages;

  BitmapAllocator(l4_size_t buffer_size_in_pages)
    : _free_pages(buffer_size_in_pages, true)
  {
    // allocate buffer of pages
    L4Re::Env const *env = L4Re::Env::env();
    _buffer_cap = chkcap(L4Re::Util::cap_alloc.alloc<L4Re::Dataspace>(),
                        "buffer cap alloc");
    l4_size_t buffer_size = buffer_size_in_pages << L4_PAGESHIFT;
    chksys(env->mem_alloc()->alloc(buffer_size, _buffer_cap),
           "buffer mem alloc");

    // prepare address space
    _buffer_addr = 0;
    L4Re::Rm::Flags rm_flags = L4Re::Rm::F::RWX
                               | L4Re::Rm::F::Search_addr;
    chksys(env->rm()->attach(&_buffer_addr, buffer_size, rm_flags, _buffer_cap),
           "buffer as attach");

    l4_addr_t buffer_end_addr = _buffer_addr + buffer_size;
    L4Re::Dataspace::Flags ds_flags = L4Re::Dataspace::F::RWX;
    chksys(_buffer_cap->map_region(0, ds_flags, _buffer_addr, buffer_end_addr),
           "buffer mem map");

    printf("Initialised DsL4ReAllocator mem_pool.\n");
    printf("size: %ld\taddr: 0x%08lX\n", buffer_size, _buffer_addr);
  };

  BitmapAllocator(BitmapAllocator const &bma) = delete;

public:
  page_t alloc_p(void)
  {
    // search for a free page
    std::vector<bool>::iterator free_page;
    for (free_page = _free_pages.begin();
         free_page != _free_pages.end();
         free_page++)
    {
      if (*free_page)
        break;
    }

    if (free_page == _free_pages.end())
    {
      // TODO: do proper error handling
      printf("Allocator cannot serve this request!\n");
      return 0;
    };

    // mark page as allocated
    *free_page = false;

    // convert allocation into pointer
    l4_size_t free_page_idx = free_page - _free_pages.begin();
    l4_addr_t free_page_addr = _buffer_addr + (free_page_idx << L4_PAGESHIFT);

    return free_page_addr;
  };

  void free_p(page_t page)
  {
    // find index of page to free
    l4_size_t page_offs_in_buffer = page - _buffer_addr;
    l4_size_t page_idx = page_offs_in_buffer >> L4_PAGESHIFT;

    // mark page as freed
    *(_free_pages.begin() + page_idx) = true;

    // return page to the system
    _buffer_cap->clear(page_offs_in_buffer, L4_PAGESIZE);
  };
};

class DsL4ReAllocator : public L4ReAllocator
{
private:
  BitmapAllocator _imm_pool;
  extint_map_t _ds_map;

public:
  DsL4ReAllocator() : _imm_pool(65536)
  {};

  int op_create(L4::Factory::Rights,
                L4::Ipc::Cap<void> &res,
                l4_umword_t type,
                L4::Ipc::Varg_list<> &&args) override
  {
    // check protocol
    if (type != L4Re::Dataspace::Protocol)
      return -L4_ENODEV;

    // sanitize arguments
    L4::Ipc::Varg tags[3];
    for (auto &tag : tags) 
      tag = args.pop_front();

    if (!tags[0].is_of_int())
      return -L4_EINVAL;
    l4_size_t mem_size =
      l4_round_size(tags[0].value<l4_size_t>(), L4_PAGESHIFT);

    L4Re::Dataspace::Flags mem_flags =
      tags[1].is_of_int() ?
        static_cast<L4Re::Dataspace::Flags>(tags[1].value<unsigned long>())
        : L4Re::Dataspace::F::Ro;

    l4_size_t mem_align =
          tags[2].is_of_int() ? tags[2].value<l4_size_t>() : 0;

    // allocate backing memory
    L4Re::Env const *env = L4Re::Env::env();
    L4::Cap<L4Re::Dataspace> mem_cap =
        chkcap(L4Re::Util::cap_alloc.alloc<L4Re::Dataspace>(),
               "ds cap alloc");

    chksys(env->mem_alloc()->alloc(mem_size, mem_cap, 0, mem_align),
           "ds mem alloc");

    // attach ds and map into address space (for internal use)
    l4_addr_t mem_addr_int = 0;
    L4Re::Rm::Flags rm_flags = L4Re::Rm::F::RWX | L4Re::Rm::F::Search_addr;
    chksys(env->rm()->attach(&mem_addr_int, mem_size, rm_flags, mem_cap),
           "ds as attach (internal)");
    chksys(mem_cap->map_region(0, L4Re::Dataspace::F::RWX, mem_addr_int,
                               mem_addr_int + mem_size),
           "ds mem map (internal)");

    // reserve region and map into address space (for external use)
    l4_addr_t mem_addr_ext = 0;
    rm_flags |= L4Re::Rm::F::Reserved;
    chksys(env->rm()->reserve_area(&mem_addr_ext, mem_size, rm_flags),
           "ds as reserve (external)");
    chksys(mem_cap->map_region(0, L4Re::Dataspace::F::RWX, mem_addr_ext,
                               mem_addr_ext + mem_size),
           "ds mem map (external)");

    // log the internal external ds mapping
    _ds_map.push_back({mem_addr_ext, mem_addr_int, mem_cap});

    // prepare dataspace to hand out
    // TODO: add delete in destructor else memory leak here
    Spmm::Dataspace *ds =
      new Spmm::Dataspace(mem_addr_ext, mem_size, mem_flags, this->manager);

    chkcap(server.registry()->register_obj(ds),
           "Spmm dataspace register");
    res = L4::Ipc::make_cap_rw(ds->obj_cap());

    // register pages for same-page merging
    for (l4_addr_t i = mem_addr_ext;
         i < mem_addr_ext + mem_size;
         i += L4_PAGESIZE)
      this->manager->register_p(this, i);

    printf("handing out dataspace @ addr: 0x%08lX with size: %ld\n", 
            mem_addr_ext, mem_size);

    return L4_EOK;
  };

  page_t alloc_imm_p([[maybe_unused]] page_t p) override
  {
    this->manager->inc_pages_shared(this, 1);
    return _imm_pool.alloc_p();
  };

  page_t alloc_vol_p(page_t p) override
  {
    this->manager->dec_pages_sharing(this, 1);
    //printf("alloc_vol: 0x%08lX\n", p);
    for (extint_t &m : _ds_map)
    {
      l4_size_t ds_size = m.ds_cap_int->size();
      if ((m.ds_start_ext <= p) && ((p - m.ds_start_ext) < ds_size))
        return m.ds_start_int + (p - m.ds_start_ext);
    }
    printf("Fallthrough! ");
    printf("You allocated a page (0x%08lX) that is not in a dataspace of this allocator!\n", p);
    return 0;
  };

  void free_imm_p(page_t p) override
  {
    this->manager->dec_pages_shared(this, 1);
    _imm_pool.free_p(p);
  };

  void free_vol_p(page_t p) override
  {
    this->manager->inc_pages_sharing(this, 1);
    //printf("free_vol: 0x%08lX\n", p);
    for (extint_t &m : _ds_map)
    {
      l4_size_t ds_size = m.ds_cap_int->size();
      if ((m.ds_start_ext <= p) && ((p - m.ds_start_ext) < ds_size))
      {
        m.ds_cap_int->clear(p - m.ds_start_ext, L4_PAGESIZE);
        return;
      }
    }
    printf("Fallthrough! ");
    printf("You freed a page (0x%08lX) that is not in a dataspace of this allocator!\n", p);
  };
};

} //Spmm
