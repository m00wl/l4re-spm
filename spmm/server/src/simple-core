// vim:set ft=cpp:

#pragma once

#include <l4/re/error_helper>
#include <l4/re/util/br_manager>
#include <l4/re/util/object_registry>
#include <pthread-l4.h>

#include <cstdio>

#include "allocator"
#include "mediator"
#include "queue"
#include "worker"

using L4Re::chkcap;

extern L4Re::Util::Registry_server<L4Re::Util::Br_manager_hooks> server;

namespace Spmm
{

class SimpleCore : public Core
{
private:
  L4ReAllocator *_a;
  Queue *_q;
  Worker *_w;

  void _pt_start(void *(*start_routine) (void *arg), void *arg)
  {
    pthread_t t;
    pthread_attr_t ta;
    pthread_attr_init(&ta);
    if (pthread_create(&t, &ta, start_routine, arg))
    {
      //printf("pthread_create failure\n");
      while (1);
    }
    pthread_attr_destroy(&ta);
  }

  static void *_pt_start_w(void *arg)
  {
    static_cast<Spmm::Worker *>(arg)->run();
    return nullptr;
  }

  static void *_pt_start_a(void *arg)
  {
    Spmm::L4ReAllocator *a = static_cast<Spmm::L4ReAllocator *>(arg);
    chkcap(server.registry()->register_obj(a, "spmm_allocator"),
           "Spmm allocator register");
    server.loop();
    server.registry()->unregister_obj(a);
    return nullptr;
  }

public:
  SimpleCore(L4ReAllocator *a, Queue *q, Worker *w) : _a(a), _q(q), _w(w)
  {
    this->_a->set_core(this);
    this->_q->set_core(this);
    this->_w->set_core(this);
    //this->_pt_start(this->_pt_start_a, _a);
    this->_pt_start(this->_pt_start_w, _w);
  }

  // core:
  void
  merge(Component *caller) const override
  {

  }

  void
  unmmerge(Component *caller) const override
  {

  }

  // allocator:
  l4_addr_t
  palloc([[maybe_unused]] Component *caller) const override
  {
    return _a->palloc();
  }

  void
  pfree([[maybe_unused]] Component *caller, l4_addr_t p) const override
  {
    _a->pfree(p);
  }

  // queue:
  void
  pinsert([[maybe_unused]] Component *caller, l4_addr_t p) const override
  {
    _q->pinsert(p);
  }

  void
  premove([[maybe_unused]] Component *caller, l4_addr_t p) const override
  {
    _q->premove(p);
  }

  l4_addr_t
  pget_next([[maybe_unused]] Component *caller) const override
  {
    return _q->pget_next();
  }

  // worker:
  void
  run([[maybe_unused]] Component *caller) const override
  {
    _w->run();
  }

  void
  pinc_refcnt([[maybe_unused]] Component *caller, l4_addr_t p) const override
  {
    _w->pinc_refcnt(p);
  }

  void
  pdec_refcnt([[maybe_unused]] Component *caller, l4_addr_t p) const override
  {
    _w->pdec_refcnt(p);
  }
};

} //Spmm
