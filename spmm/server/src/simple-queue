// vim:set ft=cpp:

#pragma once

#include <list>
#include <mutex>

#include "queue"

namespace Spmm
{

typedef std::list<page_t> SimpleList;

class SimpleQueue : public Queue
{
private:
  SimpleList _l;
  SimpleList::iterator _i;
  std::mutex _m;
public:
  SimpleQueue() { _i = _l.begin(); }

  void
  register_p(page_t p) override
  {
    std::lock_guard<std::mutex> const lock(_m);
    _l.push_back(p);
    this->manager->inc_pages_unshared(this, 1);
    if (_l.size() == 1)
      _i = _l.begin();
  }

  void
  unregister_p(page_t p) override
  {
    std::lock_guard<std::mutex> const lock(_m);
    // TODO: std::list::remove() ?
    for (SimpleList::iterator it = _l.begin(); it != _l.end(); it++)
    {
      if (*it == p)
      {
        if (it == _i)
        {
          _i++;
          if (_i == _l.end())
            _i = _l.begin();
        }
        _l.erase(it);
        if (!_l.size())
          _i = _l.begin();
        this->manager->dec_pages_unshared(this, 1);
        return;
      }
    }
    //printf("fallthrough! you unregistered a page that was not previously registered\n");
  }

  page_t
  get_next_p(void) override
  {
    std::lock_guard<std::mutex> const lock(_m);
    if (_l.empty())
      return 0;
    page_t next = *_i;
    _i++;
    if (_i == _l.end())
    {
      _i = _l.begin();
      // TODO: think about off-by-1-page error here
      this->manager->inc_full_scans(this);
    }
    return next;
  }
};

} //Spmm
