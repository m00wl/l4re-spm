// vim:set ft=cpp:

#pragma once

#include <l4/util/util.h>

#include <cstdio>
#include <cstring>
#include <list>

#include "worker"

namespace Spmm
{

typedef std::list<page_t> SimpleList;

class SimpleWorker : public Worker
{
private:
  SimpleList _stable;
  SimpleList _unstable;
  l4_uint64_t _count;
  l4_uint64_t _sleep;

  page_t search_list(page_t subject, SimpleList *list)
  {
    for (page_t &p : *list)
    {
      printf("comparing %lX to %lX\n", subject, p);
      if (!(memcmp(reinterpret_cast<void const *>(subject),
                   reinterpret_cast<void const *>(p),
                   L4_PAGESIZE)))
      {
        printf("found match!\n");
        return p;
      }
    }
    return 0;
  }

public:
  SimpleWorker(l4_uint64_t c, l4_uint64_t s) : _count(c), _sleep(s) {}

  void run(void) override
  {
    l4_sleep(30000);
    printf("worker run...\n");
    _stable.clear();
    _unstable.clear();

    while(1)
    {
      //pass
      printf("worker scan...\n");
      for (unsigned int i = 0; i < _count; i++)
      {
        page_t next = this->manager->get_next_p(this);
        if (!next)
          break;

        if (i < 65536)
        {
          _unstable.push_back(next);
          continue;
        }

        page_t match = search_list(next, &(this->_stable));
        if (match)
          this->manager->merge_imm_p(this, match, next);
        else
        {
          match = search_list(next, &(this->_unstable));
          if (match)
          {
            page_t p = this->manager->merge_vol_p(this, match, next);

            if (!p)
              continue;

            _stable.push_back(p);
            _unstable.remove(match);
          }
          else
            _unstable.push_back(next);
        }
      }

      //sleep
      printf("worker sleep...\n");
      l4_sleep(_sleep);
      _unstable.clear();
    }
  }

  void inc_p_refcnt(page_t p) override
  {

  }

  void dec_p_refcnt(page_t p) override
  {

  }
};

} //Spmm
